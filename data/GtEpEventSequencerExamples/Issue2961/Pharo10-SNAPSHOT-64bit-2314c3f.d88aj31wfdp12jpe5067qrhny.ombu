OmEntry {	#tags : {		#author : 'akg',		#time : DateAndTime [ '2022-12-17T18:09:19.643817+01:00' ],		#prior : OmReference [ 'Pharo10-SNAPSHOT-64bit-2314c3f.bv2k87kq4fxh8kky06axflhqu', '10' ],		#self : OmReference [ '1' ]	},	#content : EpGenericRefactoring {		#storeString : '(RBRemoveClassRefactoring classNames: #(#Issue2961ClassRenamed))'	}}OmEntry {	#tags : {		#author : 'akg',		#prior : OmReference [ '1' ],		#self : OmReference [ '2' ],		#time : DateAndTime [ '2022-12-17T18:09:19.794586+01:00' ],		#trigger : @3	},	#content : EpClassRemoval {		#classRemoved : RGClassDefinition {			#annotations : IdentityDictionary {				#definitionSource : 'Object subclass: #Issue2961ClassRenamed\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpackage: #Issue2961',				#traitCompositionSource : '{}',				#superclassName : 'Object'			},			#name : #Issue2961ClassRenamed,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#definitionSource : 'Issue2961ClassRenamed class\r\tinstanceVariableNames: \'\'',					#traitCompositionSource : '{}'				},				#name : #'AnObsoleteIssue2961ClassRenamed class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #AnObsoleteIssue2961ClassRenamed,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #Issue2961,			#package : #Issue2961,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'akg',		#time : DateAndTime [ '2022-12-17T18:09:23.914504+01:00' ],		#prior : OmReference [ '2' ],		#self : OmReference [ '3' ]	},	#content : EpGenericRefactoring {		#storeString : '(RBRemoveClassRefactoring classNames: #(#Issue2961TraitRenamed))'	}}OmEntry {	#tags : {		#author : 'akg',		#prior : OmReference [ '3' ],		#self : OmReference [ '4' ],		#time : DateAndTime [ '2022-12-17T18:09:24.016337+01:00' ],		#trigger : @3	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Issue2961TraitRenamed classTrait',				#isMetaSide : true			},			#name : #hasTraitComposition,			#protocol : #testing,			#sourceCode : 'hasTraitComposition\r\t\r\t^ self traitComposition isEmpty not',			#stamp : '',			#package : #Issue2961		}	}}OmEntry {	#tags : {		#author : 'akg',		#prior : OmReference [ '4' ],		#self : OmReference [ '5' ],		#time : DateAndTime [ '2022-12-17T18:09:24.017059+01:00' ],		#trigger : OmReference [ '3' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Issue2961TraitRenamed classTrait',				#isMetaSide : true			},			#name : #'recompile:from:',			#protocol : #recompilation,			#sourceCode : 'recompile: selector from: oldClass\r\t"Compile the method associated with selector in the receiver\'s method dictionary."\r\r\t| method newMethod |\r\tmethod := oldClass compiledMethodAt: selector.\r\tnewMethod := self compiler\r\t\t\t\tsource: (oldClass sourceCodeAt: selector);\r\t\t\t\tclass: self;\r\t\t\t\tfailBlock: [^ self];\r\t\t\t\tcompiledMethodTrailer: method trailer;\r\t\t\t\tcompile.   "Assume OK after proceed from SyntaxError"\r\tselector == newMethod selector ifFalse: [self error: \'selector changed!\'].\r\t\r\tmethod properties \r\t\tat: #traitSource \r\t\tifPresent: [ :aSource | newMethod propertyAt: #traitSource put: aSource].\r\t\r\tself addSelector: selector withRecompiledMethod: newMethod.',			#stamp : '',			#package : #Issue2961		}	}}OmEntry {	#tags : {		#author : 'akg',		#prior : OmReference [ '5' ],		#self : OmReference [ '6' ],		#time : DateAndTime [ '2022-12-17T18:09:24.017618+01:00' ],		#trigger : OmReference [ '3' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Issue2961TraitRenamed classTrait',				#isMetaSide : true			},			#name : #localSelectors,			#protocol : #'accessing - method dictionary',			#sourceCode : 'localSelectors\r\t\r\t^ self localMethodDict keys',			#stamp : '',			#package : #Issue2961		}	}}OmEntry {	#tags : {		#author : 'akg',		#prior : OmReference [ '6' ],		#self : OmReference [ '7' ],		#time : DateAndTime [ '2022-12-17T18:09:24.017922+01:00' ],		#trigger : OmReference [ '3' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Issue2961TraitRenamed classTrait',				#isMetaSide : true			},			#name : #'findOriginClassOf:',			#protocol : #testing,			#sourceCode : 'findOriginClassOf: aMethod\r\r\t"I return the myself or the trait that has the original implementation of a method.\r\tIf the method is an alias, the returned class includes the original aliased method"\r\r\t(aMethod hasProperty: #traitSource) \r\t\tifTrue: [ ^ aMethod traitSource innerClass ]. \r\r\t(self includesLocalSelector: aMethod selector)\r\t\tifTrue: [ ^ self ].\r\r\t^ (self traitComposition traitDefining: aMethod selector ifNone: [ ^ self ]) innerClass',			#stamp : '',			#package : #Issue2961		}	}}OmEntry {	#tags : {		#author : 'akg',		#prior : OmReference [ '7' ],		#self : OmReference [ '8' ],		#time : DateAndTime [ '2022-12-17T18:09:24.018151+01:00' ],		#trigger : OmReference [ '3' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Issue2961TraitRenamed classTrait',				#isMetaSide : true			},			#name : #allTraits,			#protocol : #querying,			#sourceCode : 'allTraits\r\t^ self traitComposition allTraits',			#stamp : '',			#package : #Issue2961		}	}}OmEntry {	#tags : {		#author : 'akg',		#prior : OmReference [ '8' ],		#self : OmReference [ '9' ],		#time : DateAndTime [ '2022-12-17T18:09:24.018392+01:00' ],		#trigger : OmReference [ '3' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Issue2961TraitRenamed classTrait',				#isMetaSide : true			},			#name : #'traitComposition:',			#protocol : #accessing,			#sourceCode : 'traitComposition: aComposition\r\t\r\taComposition asTraitComposition allTraits do: [ :aMaybeTrait |\r\t\taMaybeTrait isTrait ifFalse: [ \r\t\t\tself error: \'All the members of the trait composition should be traits\' ]].\r\t\t\r\tself class baseComposition: aComposition',			#stamp : '',			#package : #Issue2961		}	}}OmEntry {	#tags : {		#author : 'akg',		#prior : OmReference [ '9' ],		#self : OmReference [ '10' ],		#time : DateAndTime [ '2022-12-17T18:09:24.018626+01:00' ],		#trigger : OmReference [ '3' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Issue2961TraitRenamed classTrait',				#isMetaSide : true			},			#name : #traitComposition,			#protocol : #accessing,			#sourceCode : 'traitComposition\r\t"My trait composition is in my class. So I do not need to recompile the methods when installing them during bootstrap"\r\t^ self class baseComposition',			#stamp : '',			#package : #Issue2961		}	}}OmEntry {	#tags : {		#author : 'akg',		#prior : OmReference [ '10' ],		#self : OmReference [ '11' ],		#time : DateAndTime [ '2022-12-17T18:09:24.019068+01:00' ],		#trigger : OmReference [ '3' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Issue2961TraitRenamed classTrait',				#isMetaSide : true			},			#name : #'fileOutLocalMethodsInCategory:on:',			#protocol : #'*CodeExport-Traits',			#sourceCode : 'fileOutLocalMethodsInCategory: aSymbol on: aFileStream\r\t| selectors |\r\t\r\taFileStream cr.\r\tselectors := self selectorsToFileOutCategory: aSymbol.\r\t\t\r\tselectors do: [:sel | \r\t\t((self isLocalSelector: sel) or: [ (self traitComposition selectors includes: sel) not]) ifTrue: [ \r\t\tself printMethodChunk: sel on: aFileStream ]].\r\t\r\t^ self',			#stamp : '',			#package : #CodeExport-Traits		}	}}OmEntry {	#tags : {		#author : 'akg',		#prior : OmReference [ '11' ],		#self : OmReference [ '12' ],		#time : DateAndTime [ '2022-12-17T18:09:24.019306+01:00' ],		#trigger : OmReference [ '3' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Issue2961TraitRenamed classTrait',				#isMetaSide : true			},			#name : #localMethodDict,			#protocol : #accessing,			#sourceCode : 'localMethodDict\r\t"The local methodDict is in the metaclass. In this way I do not have to recompile the methods during the bootstrap when we don\'t have a compiler."\r\t^ self class baseLocalMethods',			#stamp : '',			#package : #Issue2961		}	}}OmEntry {	#tags : {		#author : 'akg',		#prior : OmReference [ '12' ],		#self : OmReference [ '13' ],		#time : DateAndTime [ '2022-12-17T18:09:24.019532+01:00' ],		#trigger : OmReference [ '3' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Issue2961TraitRenamed classTrait',				#isMetaSide : true			},			#name : #traits,			#protocol : #accessing,			#sourceCode : 'traits\r\t^ self traitComposition traits',			#stamp : '',			#package : #Issue2961		}	}}OmEntry {	#tags : {		#author : 'akg',		#prior : OmReference [ '13' ],		#self : OmReference [ '14' ],		#time : DateAndTime [ '2022-12-17T18:09:24.019788+01:00' ],		#trigger : OmReference [ '3' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Issue2961TraitRenamed classTrait',				#isMetaSide : true			},			#name : #'recategorizeSelector:from:to:',			#protocol : #categories,			#sourceCode : 'recategorizeSelector: selector from: oldCategory to: newCategory\r\t| original |\r\t\r\t"When a method is recategorized I have to classify the method, but also recategorize the aliases pointing to it"\r\t\r\toriginal := self organization categoryOfElement: selector ifAbsent: [ ^ self ].\r\r\t"If it is nil is because it is a removal. It will removed when the method is removed."\r\tnewCategory ifNil: [ ^ self ].\r\r\toriginal = oldCategory\r\t\tifTrue: [ self organization classify: selector under: newCategory suppressIfDefault: true ].\r\r\t(self traitComposition reverseAlias: selector) do: [ :e | \r\t\tself recategorizeSelector: e from: oldCategory to: newCategory. \r\t\tself notifyOfRecategorizedSelector: e from: oldCategory to: newCategory ].\r\t\r\tself organization removeEmptyCategories',			#stamp : '',			#package : #Issue2961		}	}}OmEntry {	#tags : {		#author : 'akg',		#prior : OmReference [ '14' ],		#self : OmReference [ '15' ],		#time : DateAndTime [ '2022-12-17T18:09:24.020013+01:00' ],		#trigger : OmReference [ '3' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Issue2961TraitRenamed classTrait',				#isMetaSide : true			},			#name : #'isLocalMethodsProtocol:',			#protocol : #testing,			#sourceCode : 'isLocalMethodsProtocol: aProtocol\r\t"Checks if the protocol has local selectors"\r\r\taProtocol methodSelectors ifEmpty: [ ^ true ].\r\t^ aProtocol methodSelectors anySatisfy: [ :each | self isLocalSelector: each ]',			#stamp : '',			#package : #Issue2961		}	}}OmEntry {	#tags : {		#author : 'akg',		#prior : OmReference [ '15' ],		#self : OmReference [ '16' ],		#time : DateAndTime [ '2022-12-17T18:09:24.02023+01:00' ],		#trigger : OmReference [ '3' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Issue2961TraitRenamed classTrait',				#isMetaSide : true			},			#name : #'includesLocalSelector:',			#protocol : #testing,			#sourceCode : 'includesLocalSelector: aSymbol\r\t^ self isLocalSelector: aSymbol',			#stamp : '',			#package : #Issue2961		}	}}OmEntry {	#tags : {		#author : 'akg',		#prior : OmReference [ '16' ],		#self : OmReference [ '17' ],		#time : DateAndTime [ '2022-12-17T18:09:24.020459+01:00' ],		#trigger : OmReference [ '3' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Issue2961TraitRenamed classTrait',				#isMetaSide : true			},			#name : #'removeSelector:',			#protocol : #removing,			#sourceCode : 'removeSelector: aSelector\r\r\t"When a selector is removed it should be notified to my users.\r\tCheck the class TraitChange for more details"\r\tsuper removeSelector: aSelector.\r\tself localMethodDict removeKey: aSelector ifAbsent: [  ].\r\r\tTraitChange removeSelector: aSelector on: self.',			#stamp : '',			#package : #Issue2961		}	}}OmEntry {	#tags : {		#author : 'akg',		#prior : OmReference [ '17' ],		#self : OmReference [ '18' ],		#time : DateAndTime [ '2022-12-17T18:09:24.020799+01:00' ],		#trigger : OmReference [ '3' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Issue2961TraitRenamed classTrait',				#isMetaSide : true			},			#name : #'addAndClassifySelector:withMethod:inProtocol:',			#protocol : #'accessing - method dictionary',			#sourceCode : 'addAndClassifySelector: selector withMethod: compiledMethod inProtocol: aCategory\r\t\r\t"When a new methods is added, I add it to the localMethodDict and also propagate the changes to my users"\r\tself localMethodDict at: selector put: compiledMethod.\r\t\r\tsuper\r\t\taddAndClassifySelector: selector\r\t\twithMethod: compiledMethod\r\t\tinProtocol: aCategory.\r\r\tTraitChange addSelector: selector on: self.\t',			#stamp : '',			#package : #Issue2961		}	}}OmEntry {	#tags : {		#author : 'akg',		#prior : OmReference [ '18' ],		#self : OmReference [ '19' ],		#time : DateAndTime [ '2022-12-17T18:09:24.021019+01:00' ],		#trigger : OmReference [ '3' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Issue2961TraitRenamed classTrait',				#isMetaSide : true			},			#name : #'isLocalSelector:',			#protocol : #testing,			#sourceCode : 'isLocalSelector: aSelector\r\t\r\t^ self localMethodDict includesKey: aSelector',			#stamp : '',			#package : #Issue2961		}	}}OmEntry {	#tags : {		#author : 'akg',		#prior : OmReference [ '19' ],		#self : OmReference [ '20' ],		#time : DateAndTime [ '2022-12-17T18:09:24.021333+01:00' ],		#trigger : OmReference [ '3' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Issue2961TraitRenamed classTrait',				#isMetaSide : true			},			#name : #'addSelector:withRecompiledMethod:',			#protocol : #'accessing - method dictionary',			#sourceCode : 'addSelector: selector withRecompiledMethod: compiledMethod \r\t"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"\r\r\tcompiledMethod isFromTrait \r\t\tifTrue: [ ^ super addSelector: selector withRecompiledMethod: compiledMethod ].\r\t\r\tself localMethodDict at: selector put: compiledMethod.\r\tsuper addSelector: selector withRecompiledMethod: compiledMethod.\r\tTraitChange addSelector: selector on: self',			#stamp : '',			#package : #Issue2961		}	}}OmEntry {	#tags : {		#author : 'akg',		#prior : OmReference [ '20' ],		#self : OmReference [ '21' ],		#time : DateAndTime [ '2022-12-17T18:09:24.021559+01:00' ],		#trigger : OmReference [ '3' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Issue2961TraitRenamed classTrait',				#isMetaSide : true			},			#name : #'localMethodDict:',			#protocol : #accessing,			#sourceCode : 'localMethodDict: aMethodDictionary\r\t^ self class baseLocalMethods: aMethodDictionary ',			#stamp : '',			#package : #Issue2961		}	}}OmEntry {	#tags : {		#author : 'akg',		#prior : OmReference [ '21' ],		#self : OmReference [ '22' ],		#time : DateAndTime [ '2022-12-17T18:09:24.02182+01:00' ],		#trigger : OmReference [ '3' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Issue2961TraitRenamed classTrait',				#isMetaSide : true			},			#name : #'findOriginMethodOf:',			#protocol : #testing,			#sourceCode : 'findOriginMethodOf: aMethod\r\r\t"I return the original method for a aMethod.\r\tIf this is a local method, the original method is itself.\r\tIf it cames from a trait composition I look for the method in the trait composition.\r\tFirst I try with the trait stored in the traitSource. \r\tIf it is an aliased or conflicting method, the method is look up in the whole trait composition"\r\r\t(self includesLocalSelector: aMethod selector)\r\t\tifTrue: [ ^ aMethod ].\r\r\t(aMethod hasProperty: #traitSource)\r\t\tifTrue: [ |newSelector|\r\t\t\tnewSelector := self traitComposition originSelectorOf: aMethod selector.\r\t\t\t^ aMethod traitSource compiledMethodAt: newSelector ifAbsent: [aMethod] ].\r\r\t^ (self traitComposition traitDefining: aMethod selector ifNone: [ self ])\r\t\tcompiledMethodAt: aMethod selector ifAbsent: [ ^ aMethod ]\t\t\r',			#stamp : '',			#package : #Issue2961		}	}}OmEntry {	#tags : {		#author : 'akg',		#prior : OmReference [ '22' ],		#self : OmReference [ '23' ],		#time : DateAndTime [ '2022-12-17T18:09:24.022076+01:00' ],		#trigger : OmReference [ '3' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Issue2961TraitRenamed classTrait',				#isMetaSide : true			},			#name : #'removeFromComposition:',			#protocol : #trait-composition,			#sourceCode : 'removeFromComposition: aTrait\r\r\tself setTraitComposition: (self traitComposition copyWithoutTrait: aTrait asTraitComposition)',			#stamp : '',			#package : #Issue2961		}	}}OmEntry {	#tags : {		#author : 'akg',		#prior : OmReference [ '23' ],		#self : OmReference [ '24' ],		#time : DateAndTime [ '2022-12-17T18:09:24.02239+01:00' ],		#trigger : OmReference [ '3' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Issue2961TraitRenamed classTrait',				#isMetaSide : true			},			#name : #'addSelector:withMethod:',			#protocol : #'accessing - method dictionary',			#sourceCode : 'addSelector: selector withMethod: compiledMethod\r\t"When a new selector is installed in a class I insert the selector in the local methodDict and propagate the changes to my users"\r\t\r\tself localMethodDict at: selector put: compiledMethod.\r\tsuper addSelector: selector withMethod: compiledMethod.\r\tTraitChange addSelector: selector on: self',			#stamp : '',			#package : #Issue2961		}	}}OmEntry {	#tags : {		#author : 'akg',		#prior : OmReference [ '24' ],		#self : OmReference [ '25' ],		#time : DateAndTime [ '2022-12-17T18:09:24.02262+01:00' ],		#trigger : OmReference [ '3' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Issue2961TraitRenamed classTrait',				#isMetaSide : true			},			#name : #localMethods,			#protocol : #accessing,			#sourceCode : 'localMethods\r\t"returns the methods of classes excluding the ones of the traits that the class uses" \r\t \r\t^ self localMethodDict values',			#stamp : '',			#package : #Issue2961		}	}}OmEntry {	#tags : {		#author : 'akg',		#prior : OmReference [ '25' ],		#self : OmReference [ '26' ],		#time : DateAndTime [ '2022-12-17T18:09:24.022913+01:00' ],		#trigger : OmReference [ '3' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Issue2961TraitRenamed classTrait',				#isMetaSide : true			},			#name : #'isAliasSelector:',			#protocol : #testing,			#sourceCode : 'isAliasSelector: aSymbol\r\t"Return true if the selector aSymbol is an alias defined\r\tin my or in another composition somewhere deeper in \r\tthe tree of traits compositions."\r\r\t^ self traitComposition isAliasSelector: aSymbol',			#stamp : '',			#package : #Issue2961		}	}}OmEntry {	#tags : {		#author : 'akg',		#prior : OmReference [ '26' ],		#self : OmReference [ '27' ],		#time : DateAndTime [ '2022-12-17T18:09:24.023211+01:00' ],		#trigger : OmReference [ '3' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Issue2961TraitRenamed classTrait',				#isMetaSide : true			},			#name : #doRebuildMethodDictionary,			#protocol : #initialization,			#sourceCode : 'doRebuildMethodDictionary\r\t| selectors removedSelectors removeFromOrganization modified|\r\r\t"During the creation of the class or after a change in the traitComposition, the whole method dictionary is calculated.\r\tIf I return true, my users should be updated"\r\r\t"1. I recreate the local methodDict"\r\tmodified := false.\r\tself methodDict valuesDo: [ :m | m traitSource ifNil: [ self localMethodDict at: m selector put: m ]].\r\r\t"2. I filter the selectors from the trait composition, rejecting the ones that are locally defined.\r\tAnd then I install the methods in myself. The trait composition only install the method if it is needed."\r\tselectors := self traitComposition selectors reject: [ :e | (self localMethodDict includesKey: e) ].\r\tselectors do: [ :e | modified := modified | (self traitComposition installSelector: e into: self replacing: false)].\r\r\t"3. I handle the methods that I have and they are no more in the traitComposition."\r\tremovedSelectors := self methodDict keys reject: [ :aSelector | (selectors includes: aSelector) or: [ self localMethodDict includesKey: aSelector] ].\r\tmodified := modified | (removedSelectors isNotEmpty).\r\tremovedSelectors do: [ :aSelector | self methodDict removeKey: aSelector ].\r\r\t"4. Finally, I remove these methods from my class organization"\r\tremoveFromOrganization := self organization allMethodSelectors reject: [:e | self methodDict includesKey: e ].\r\tremoveFromOrganization do: [ :aSelector | self organization removeElement: aSelector ].\r\r\t^ modified',			#stamp : '',			#package : #Issue2961		}	}}OmEntry {	#tags : {		#author : 'akg',		#prior : OmReference [ '27' ],		#self : OmReference [ '28' ],		#time : DateAndTime [ '2022-12-17T18:09:24.02343+01:00' ],		#trigger : OmReference [ '3' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Issue2961TraitRenamed classTrait',				#isMetaSide : true			},			#name : #'isLocalAliasSelector:',			#protocol : #testing,			#sourceCode : 'isLocalAliasSelector: aSymbol\r\t"Return true if the selector aSymbol is an alias defined\r\tin my trait composition."\r\r\t^ self traitComposition isLocalAliasSelector: aSymbol',			#stamp : '',			#package : #Issue2961		}	}}OmEntry {	#tags : {		#author : 'akg',		#prior : OmReference [ '28' ],		#self : OmReference [ '29' ],		#time : DateAndTime [ '2022-12-17T18:09:24.023654+01:00' ],		#trigger : OmReference [ '3' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Issue2961TraitRenamed classTrait',				#isMetaSide : true			},			#name : #traitCompositionString,			#protocol : #accessing,			#sourceCode : 'traitCompositionString\r\t^ self traitComposition asString',			#stamp : '',			#package : #Issue2961		}	}}OmEntry {	#tags : {		#author : 'akg',		#prior : OmReference [ '29' ],		#self : OmReference [ '30' ],		#time : DateAndTime [ '2022-12-17T18:09:24.023674+01:00' ],		#trigger : OmReference [ '3' ]	},	#content : EpTraitRemoval {		#trait : RGTraitDefinition {			#annotations : IdentityDictionary {				#definitionSource : 'Trait named: #Issue2961TraitRenamed\r\tinstanceVariableNames: \'\'\r\tpackage: #Issue2961',				#traitCompositionSource : '{}',				#superclassName : #Trait			},			#name : #Issue2961TraitRenamed,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#metaClass : RGMetatraitDefinition {				#annotations : IdentityDictionary {					#definitionSource : 'Issue2961TraitRenamed classTrait\r\tinstanceVariableNames: \'\'',					#traitCompositionSource : '{}'				},				#name : #'AnObsoleteIssue2961TraitRenamed classTrait',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #AnObsoleteIssue2961TraitRenamed,					#isMetaSide : false				},				#parent : @8,				#content : ''			},			#category : #Issue2961,			#package : #Issue2961		}	}}